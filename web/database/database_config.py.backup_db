#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
ğŸ”— DATABASE CONFIG - LOTOFÃCIL LITE
ConfiguraÃ§Ã£o centralizada do banco de dados baseada na classe funcional
Autor: AR CALHAU
Data: 04 de Agosto de 2025
"""

import pyodbc
import pandas as pd
import time
from typing import Optional, Dict, List, Any, Tuple

class DatabaseConfig:
    """ConfiguraÃ§Ã£o centralizada do banco de dados"""
    
    def __init__(self, server: str = "DESKTOP-K6JPBDS", 
                 database: str = "LOTOFACIL", 
                 driver: str = "ODBC Driver 17 for SQL Server"):
        """
        Inicializa configuraÃ§Ã£o de conexÃ£o baseada na classe funcional
        
        Args:
            server: Nome do servidor SQL Server
            database: Nome do banco de dados
            driver: Driver ODBC a ser usado
        """
        self.server = server
        self.database = database
        self.driver = driver
        
        # String de conexÃ£o testada e funcional
        self.connection_string = (
            f"DRIVER={{{self.driver}}};"
            f"SERVER={self.server};"
            f"DATABASE={self.database};"
            "Trusted_Connection=yes;"
        )
        
        # ConfiguraÃ§Ãµes de retry
        self.max_retries = 3
        self.retry_delay = 2
        self._conexao_ok = None
        
    def get_connection(self) -> Optional[pyodbc.Connection]:
        """
        ObtÃ©m uma conexÃ£o com o banco de dados com retry automÃ¡tico
        
        Returns:
            pyodbc.Connection: ConexÃ£o ativa ou None se falhar
        """
        for attempt in range(self.max_retries):
            try:
                conn = pyodbc.connect(self.connection_string)
                if attempt == 0:  # SÃ³ mostra na primeira tentativa bem-sucedida
                    print(f"âœ… ConexÃ£o estabelecida - {self.server} / {self.database}")
                return conn
                
            except pyodbc.Error as e:
                print(f"âŒ Erro na conexÃ£o (tentativa {attempt + 1}): {e}")
                if attempt < self.max_retries - 1:
                    print(f"ğŸ”„ Tentando novamente em {self.retry_delay} segundos...")
                    time.sleep(self.retry_delay)
                else:
                    print("âŒ Falha ao conectar apÃ³s todas as tentativas")
                    self._conexao_ok = False
                    return None
    
    def test_connection(self) -> bool:
        """
        Testa a conexÃ£o com o banco de dados
        
        Returns:
            bool: True se conexÃ£o bem-sucedida
        """
        print("ğŸ” Testando conexÃ£o com o banco de dados...")
        
        try:
            conn = pyodbc.connect(self.connection_string)
            cursor = conn.cursor()
            cursor.execute("SELECT 1")
            cursor.fetchone()
            cursor.close()
            conn.close()
            self._conexao_ok = True
            print(f"âœ… ConexÃ£o SQL Server OK - {self.server} / {self.database}")
            return True
        except Exception as e:
            self._conexao_ok = False
            print(f"âŒ Erro na conexÃ£o SQL Server: {e}")
            return False
    
    def execute_query(self, query: str, params: Tuple = None) -> Optional[List[List]]:
        """
        Executa uma query SELECT e retorna os resultados como lista
        
        Args:
            query (str): Query SQL
            params (tuple): ParÃ¢metros para a query
            
        Returns:
            list: Resultados da query ou None se erro
        """
        conn = self.get_connection()
        if not conn:
            return None
            
        try:
            cursor = conn.cursor()
            if params:
                cursor.execute(query, params)
            else:
                cursor.execute(query)
            
            results = cursor.fetchall()
            return [list(row) for row in results]
            
        except Exception as e:
            print(f"âŒ Erro ao executar query: {e}")
            return None
        finally:
            cursor.close()
            conn.close()
    
    def execute_query_dataframe(self, query: str, params: Optional[Tuple] = None) -> Optional[pd.DataFrame]:
        """
        Executa uma query SELECT e retorna DataFrame (para compatibilidade)
        
        Args:
            query: Query SQL a ser executada
            params: ParÃ¢metros para a query
            
        Returns:
            DataFrame com os resultados ou None se erro
        """
        conn = self.get_connection()
        if not conn:
            return None
        
        try:
            if params:
                df = pd.read_sql(query, conn, params=params)
            else:
                df = pd.read_sql(query, conn)
            return df
        except Exception as e:
            print(f"âŒ Erro ao executar query: {e}")
            return None
        finally:
            conn.close()
    
    def execute_command(self, command: str, params: Tuple = None) -> bool:
        """
        Executa um comando SQL (INSERT, UPDATE, DELETE)
        
        Args:
            command (str): Comando SQL
            params (tuple): ParÃ¢metros para o comando
            
        Returns:
            bool: True se executado com sucesso
        """
        conn = self.get_connection()
        if not conn:
            return False
            
        try:
            cursor = conn.cursor()
            if params:
                cursor.execute(command, params)
            else:
                cursor.execute(command)
            
            conn.commit()
            print(f"âœ… Comando executado com sucesso")
            return True
            
        except Exception as e:
            print(f"âŒ Erro ao executar comando: {e}")
            conn.rollback()
            return False
        finally:
            cursor.close()
            conn.close()
    
    def verificar_tabela_existe(self, nome_tabela: str) -> bool:
        """
        Verifica se uma tabela existe no banco
        
        Args:
            nome_tabela: Nome da tabela
            
        Returns:
            bool: True se existe, False caso contrÃ¡rio
        """
        query = """
        SELECT COUNT(*) as count FROM INFORMATION_SCHEMA.TABLES 
        WHERE TABLE_NAME = ?
        """
        
        conn = self.get_connection()
        if not conn:
            return False
        
        try:
            cursor = conn.cursor()
            cursor.execute(query, (nome_tabela,))
            existe = cursor.fetchone()[0] > 0
            return existe
        except Exception as e:
            print(f"âŒ Erro ao verificar tabela: {e}")
            return False
        finally:
            cursor.close()
            conn.close()
    
    def contar_registros(self, nome_tabela: str, condicao: str = "") -> int:
        """
        Conta registros em uma tabela
        
        Args:
            nome_tabela: Nome da tabela
            condicao: CondiÃ§Ã£o WHERE opcional
            
        Returns:
            int: NÃºmero de registros (0 se erro)
        """
        query = f"SELECT COUNT(*) FROM {nome_tabela}"
        if condicao:
            query += f" WHERE {condicao}"
        
        conn = self.get_connection()
        if not conn:
            return 0
        
        try:
            cursor = conn.cursor()
            cursor.execute(query)
            count = cursor.fetchone()[0]
            return count
        except Exception as e:
            print(f"âŒ Erro ao contar registros: {e}")
            return 0
        finally:
            cursor.close()
            conn.close()
    
    def inserir_lote(self, tabela: str, dados: List[Tuple], colunas: Optional[List[str]] = None) -> bool:
        """
        Insere mÃºltiplos registros em lote
        
        Args:
            tabela: Nome da tabela
            dados: Lista de tuplas com os dados
            colunas: Lista com nomes das colunas (opcional)
            
        Returns:
            bool: True se inseriu com sucesso
        """
        if not dados:
            return True
        
        # Construir SQL de inserÃ§Ã£o
        if colunas:
            cols_str = f"({', '.join(colunas)})"
            placeholders = f"({', '.join(['?' for _ in colunas])})"
        else:
            cols_str = ""
            placeholders = f"({', '.join(['?' for _ in dados[0]])})"
        
        sql = f"INSERT INTO {tabela} {cols_str} VALUES {placeholders}"
        
        conn = self.get_connection()
        if not conn:
            return False
        
        try:
            cursor = conn.cursor()
            cursor.executemany(sql, dados)
            conn.commit()
            print(f"âœ… {len(dados)} registros inseridos em {tabela}")
            return True
        except Exception as e:
            print(f"âŒ Erro ao inserir lote: {e}")
            return False
        finally:
            cursor.close()
            conn.close()
    
    @property
    def conexao_ok(self) -> Optional[bool]:
        """
        Retorna status da Ãºltima tentativa de conexÃ£o
        
        Returns:
            bool: True/False se testado, None se nunca testado
        """
        return self._conexao_ok
    
    def get_info_conexao(self) -> Dict[str, Any]:
        """
        Retorna informaÃ§Ãµes sobre a configuraÃ§Ã£o de conexÃ£o
        
        Returns:
            dict: InformaÃ§Ãµes da conexÃ£o
        """
        return {
            'server': self.server,
            'database': self.database,
            'driver': self.driver,
            'conexao_ok': self._conexao_ok,
            'connection_string': self.connection_string
        }

# InstÃ¢ncia global para uso em todo o sistema
db_config = DatabaseConfig()

def testar_conexao_sistema():
    """FunÃ§Ã£o para testar a conexÃ£o do sistema LotofÃ¡cil"""
    print("ï¿½ TESTANDO CONEXÃƒO SQL SERVER - LOTOFÃCIL LITE")
    print("=" * 60)
    
    # Testar conexÃ£o
    if db_config.test_connection():
        print(f"ğŸ“Š Servidor: {db_config.server}")
        print(f"ğŸ—„ï¸ Database: {db_config.database}")
        
        # Verificar tabelas principais baseadas na arquitetura tÃ©cnica
        tabelas_principais = [
            ('Combin_Quinze', '3,268,760 registros - Todas as combinaÃ§Ãµes de 15 nÃºmeros'),
            ('Combin_Quinas', '33,649 registros - Todas as combinaÃ§Ãµes de 5 nÃºmeros'),
            ('Combin_Duplas', '300 registros - Todas as combinaÃ§Ãµes de 2 nÃºmeros'),
            ('Combin_Ternos', '2,300 registros - Todas as combinaÃ§Ãµes de 3 nÃºmeros'),
            ('NumerosCiclos', 'AnÃ¡lise de ciclos por nÃºmero (1-25)'),
            ('Resultados_INT', 'HistÃ³rico oficial dos sorteios')
        ]
        
        print(f"\nğŸ“‹ VERIFICANDO TABELAS PRINCIPAIS:")
        tabelas_encontradas = 0
        
        for tabela, descricao in tabelas_principais:
            if db_config.verificar_tabela_existe(tabela):
                count = db_config.contar_registros(tabela)
                print(f"âœ… {tabela}: {count:,} registros")
                tabelas_encontradas += 1
            else:
                print(f"âš ï¸ {tabela}: NÃ£o encontrada")
        
        # Verifica tabela de resultados oficial
        if db_config.verificar_tabela_existe('Resultados_INT'):
            count = db_config.contar_registros('Resultados_INT')
            print(f"âœ… Resultados_INT (Oficial): {count:,} registros")
            
            # Se tem dados, mostra range de concursos
            if count > 0:
                resultado = db_config.execute_query("SELECT MIN(Concurso), MAX(Concurso) FROM Resultados_INT")
                if resultado and resultado[0][0]:
                    min_conc, max_conc = resultado[0]
                    print(f"   ğŸ“ˆ Range: Concurso {min_conc} atÃ© {max_conc}")
        
        # Verifica procedures importantes
        print(f"\nğŸ”§ VERIFICANDO PROCEDURES:")
        procedures = ['AtualizaNumerosCiclos', 'CalculaCamposApoio', 'AtualizaCombinacoes']
        
        for proc in procedures:
            query = """
            SELECT COUNT(*) FROM INFORMATION_SCHEMA.ROUTINES 
            WHERE ROUTINE_TYPE = 'PROCEDURE' AND ROUTINE_NAME = ?
            """
            resultado = db_config.execute_query(query, (proc,))
            if resultado and resultado[0][0] > 0:
                print(f"âœ… {proc}: DisponÃ­vel")
            else:
                print(f"âš ï¸ {proc}: NÃ£o encontrada")
        
        print(f"\nğŸ“Š RESUMO:")
        print(f"   â€¢ Tabelas principais encontradas: {tabelas_encontradas}/{len(tabelas_principais)}")
        
        if tabelas_encontradas >= 4:
            print(f"   ğŸ¯ Sistema compatÃ­vel com arquitetura completa!")
        elif db_config.verificar_tabela_existe('Resultados_INT'):
            print(f"   ğŸ’¡ Sistema funcional (usando Resultados_INT)")
        else:
            print(f"   âš ï¸ Execute setup_banco.py para criar estrutura bÃ¡sica")
    
    else:
        print("âŒ Falha na conexÃ£o com SQL Server")
        print("ğŸ’¡ Dicas para resolver:")
        print(f"   â€¢ Verifique se o SQL Server estÃ¡ rodando em {db_config.server}")
        print(f"   â€¢ Confirme se o banco LOTOFACIL existe")
        print("   â€¢ Teste a autenticaÃ§Ã£o Windows")
        print("   â€¢ Verifique se o serviÃ§o SQL Server estÃ¡ ativo")
    
    return db_config.conexao_ok

if __name__ == "__main__":
    # Teste da configuraÃ§Ã£o
    print("ğŸ”— TESTE DA CONFIGURAÃ‡ÃƒO DO BANCO DE DADOS")
    print("=" * 50)
    
    if testar_conexao_sistema():
        print("\nğŸ¯ Sistema pronto para uso!")
        print("ğŸ’¡ Execute 'python main.py' para usar o sistema completo")
    else:
        print("\nâš ï¸ Configure a conexÃ£o antes de usar o sistema")
        print("ğŸ“ Ajuste os parÃ¢metros no inÃ­cio do arquivo se necessÃ¡rio")
